#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_VL53L0X.h>
#include <NewPing.h>
#include <Firebase_ESP_Client.h>
#include "pitches.h"
#include "driver/ledc.h"  // API LEDC untuk core 3.x


const char* ssid     = "ssid";
const char* password = "password";

#define DATABASE_URL "default-rtdb.firebaseio.com/"
#define DATABASE_SECRET "secret"

const uint8_t POMPA1_PIN = 23;
const uint8_t POMPA2_PIN = 32;
const uint8_t POMPA3_PIN = 33;
const uint8_t POMPA4_PIN = 26;
const uint8_t MOTOR_PIN  = 27;
const uint8_t SYSTEM_PIN = 14;

const uint8_t BUZZER_PIN  = 13;  // Pacman
const uint8_t BUZZER2_PIN = 12;  // Tetris

#define CH_BUZZER1 LEDC_CHANNEL_0
#define CH_BUZZER2 LEDC_CHANNEL_1
#define TIMER_BUZZER1 LEDC_TIMER_0
#define TIMER_BUZZER2 LEDC_TIMER_1
#define LEDC_SPEED LEDC_LOW_SPEED_MODE
#define LEDC_RES LEDC_TIMER_12_BIT

const uint8_t TRIG_PIN = 18;
const uint8_t ECHO_PIN = 19;

const uint8_t TRIG2_PIN = 17;
const uint8_t ECHO2_PIN = 5;

const unsigned int MAX_DISTANCE_CM = 400;

const uint8_t SDA_PIN = 21;
const uint8_t SCL_PIN = 22;

Adafruit_VL53L0X lox = Adafruit_VL53L0X();
NewPing sonar(TRIG_PIN, ECHO_PIN, MAX_DISTANCE_CM);
NewPing sonarTank(TRIG2_PIN, ECHO2_PIN, MAX_DISTANCE_CM);

bool loxReady = false;

const uint16_t TOF_EMPTY_MM  = 100;
const uint16_t ULTRASONIC_THRESHOLD_CM = 40;
const uint16_t TANK_FULL_THRESHOLD_CM = 10;

uint16_t tof_mm   = 65535;
uint16_t us_cm    = 65535;
uint16_t tank_cm  = 65535;

unsigned long lastSend = 0;
const unsigned long sendInterval = 3000;

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ===================== TETRIS ======================
const int tetris_melody[] = {
  NOTE_E5, NOTE_B4, NOTE_C5, NOTE_D5,
  NOTE_C5, NOTE_B4, NOTE_A4,
  NOTE_A4, NOTE_C5, NOTE_E5, NOTE_D5,
  NOTE_C5, NOTE_B4, NOTE_C5, NOTE_D5,
  NOTE_E5, NOTE_C5, NOTE_A4, NOTE_A4
};
const int tetris_durations[] = {
  150,150,150,150,
  150,150,300,
  150,150,150,150,
  150,300,150,150,
  150,150,150,300
};
const int tetris_len = sizeof(tetris_melody) / sizeof(tetris_melody[0]);

bool tetrisActive = false;
unsigned long tetrisLastChange = 0;
int tetrisIndex = 0;

// ===================== PACMAN ======================
const int pacman_melody[] = {
  NOTE_B4, NOTE_B5, NOTE_FS5, NOTE_DS5,
  NOTE_B5, NOTE_FS5, NOTE_DS5, NOTE_C5,
  NOTE_C6, NOTE_G6, NOTE_E6, NOTE_C6, NOTE_G6, NOTE_E6
};
const int pacman_durations[] = {
  150,150,150,150,
  150,150,300,150,
  150,150,150,150,150,300
};
const int pacman_len = sizeof(pacman_melody) / sizeof(pacman_melody[0]);

bool pacmanActive = false;
unsigned long pacmanStartTime = 0;
unsigned long pacmanLastChange = 0;
int pacmanIndex = 0;

// ===================== LEDC FUNCTIONS ======================
void setBuzzerFreq(int channel, int freq) {
  if (freq <= 0) {
    ledc_set_duty(LEDC_SPEED, channel, 0);
    ledc_update_duty(LEDC_SPEED, channel);
    return;
  }

  ledc_timer_t timer = (channel == CH_BUZZER1) ? TIMER_BUZZER1 : TIMER_BUZZER2;
  ledc_set_freq(LEDC_SPEED, timer, freq);

  uint32_t duty = (1 << LEDC_RES) / 2;
  ledc_set_duty(LEDC_SPEED, channel, duty);
  ledc_update_duty(LEDC_SPEED, channel);
}

int readOptoButton(uint8_t pin) {
  return (digitalRead(pin) == LOW);
}

int readDevice(uint8_t pin, bool inverted = false) {
  int v = readOptoButton(pin);
  return inverted ? !v : v;
}

void readSensors() {
  if (loxReady) {
    VL53L0X_RangingMeasurementData_t m;
    lox.rangingTest(&m, false);
    tof_mm = (m.RangeStatus != 4) ? m.RangeMilliMeter : 65535;
  }

  us_cm = sonar.ping_cm();
  if (us_cm == 0) us_cm = 65535;

  tank_cm = sonarTank.ping_cm();
  if (tank_cm == 0) tank_cm = 65535;
}

// ===================== MELODY PLAYER ======================
void playTetris() {
  if (!tetrisActive) return;

  if (millis() - tetrisLastChange >= tetris_durations[tetrisIndex]) {
    setBuzzerFreq(CH_BUZZER2, tetris_melody[tetrisIndex]);
    tetrisLastChange = millis();
    tetrisIndex++;
    if (tetrisIndex >= tetris_len) tetrisIndex = 0;
  }
}

void playPacman() {
  if (!pacmanActive) return;

  if (millis() - pacmanLastChange >= pacman_durations[pacmanIndex]) {
    setBuzzerFreq(CH_BUZZER1, pacman_melody[pacmanIndex]);
    pacmanLastChange = millis();
    pacmanIndex++;
    if (pacmanIndex >= pacman_len) pacmanIndex = 0;
  }

  if (millis() - pacmanStartTime >= 15000) {
    pacmanActive = false;
    setBuzzerFreq(CH_BUZZER1, 0);
    pacmanIndex = 0;
  }
}

// ===================== BUZZER CONTROL ======================
void updateBuzzer() {
  bool tofEmpty = (tof_mm == 65535) || (tof_mm > TOF_EMPTY_MM);
  bool usEmpty  = (us_cm == 65535) || (us_cm > ULTRASONIC_THRESHOLD_CM);
  bool sensorsEmpty = tofEmpty && usEmpty;

  if (sensorsEmpty) {
    if (!tetrisActive) {
      tetrisActive = true;
      tetrisLastChange = millis();
      tetrisIndex = 0;
    }
  } else {
    tetrisActive = false;
    setBuzzerFreq(CH_BUZZER2, 0);
  }

  bool systemOn = (digitalRead(SYSTEM_PIN) == LOW);

  if (systemOn) {
    if (!pacmanActive) {
      pacmanActive = true;
      pacmanStartTime = millis();
      pacmanLastChange = millis();
      pacmanIndex = 0;
    }
  } else {
    pacmanActive = false;
    setBuzzerFreq(CH_BUZZER1, 0);
  }

  playTetris();
  playPacman();
}

void sendToFirebase() {
  if (WiFi.status() != WL_CONNECTED) return;

  int p1 = readDevice(POMPA1_PIN, true);
  int p2 = readDevice(POMPA2_PIN, true);
  int p3 = readDevice(POMPA3_PIN, true);
  int p4 = readDevice(POMPA4_PIN, true);
  int m  = readDevice(MOTOR_PIN,  true);
  int s  = readDevice(SYSTEM_PIN, true);

  int tof = (tof_mm != 65535 && tof_mm <= TOF_EMPTY_MM) ? 1 : 0;
  int us  = (us_cm  != 65535 && us_cm  <= ULTRASONIC_THRESHOLD_CM) ? 1 : 0;
  int tank = (tank_cm != 65535 && tank_cm <= TANK_FULL_THRESHOLD_CM) ? 1 : 0;

  FirebaseJson json;
  json.set("pompa1", p1);
  json.set("pompa2", p2);
  json.set("pompa3", p3);
  json.set("pompa4", p4);
  json.set("motor", m);
  json.set("system", s);
  json.set("tof", tof);
  json.set("us", us);
  json.set("tank", tank);

  Firebase.RTDB.setJSON(&fbdo, "/data", &json);
}

void setup() {
  Serial.begin(115200);

  pinMode(POMPA1_PIN, INPUT_PULLUP);
  pinMode(POMPA2_PIN, INPUT_PULLUP);
  pinMode(POMPA3_PIN, INPUT_PULLUP);
  pinMode(POMPA4_PIN, INPUT_PULLUP);
  pinMode(MOTOR_PIN,  INPUT_PULLUP);
  pinMode(SYSTEM_PIN, INPUT_PULLUP);

  ledc_timer_config_t t1 = {
    LEDC_RES,        // duty_resolution
    2000,            // freq
    LEDC_SPEED,      // speed_mode
    TIMER_BUZZER1,   // timer_num
    LEDC_AUTO_CLK    // clk_cfg
  };
  ledc_timer_config(&t1);

  ledc_timer_config_t t2 = {
    LEDC_RES,
    2000,
    LEDC_SPEED,
    TIMER_BUZZER2,
    LEDC_AUTO_CLK
  };
  ledc_timer_config(&t2);

  ledc_channel_config_t c1 = {
    BUZZER_PIN,        // gpio_num
    LEDC_SPEED,        // speed_mode
    CH_BUZZER1,        // channel
    LEDC_INTR_DISABLE, // intr type
    TIMER_BUZZER1,     // timer_sel
    0,                 // duty
    0,                 // hpoint
    {}                 // flags
  };
  ledc_channel_config(&c1);

  ledc_channel_config_t c2 = {
    BUZZER2_PIN,
    LEDC_SPEED,
    CH_BUZZER2,
    LEDC_INTR_DISABLE,
    TIMER_BUZZER2,
    0,
    0,
    {}
  };
  ledc_channel_config(&c2);

  Wire.begin(SDA_PIN, SCL_PIN);

  loxReady = lox.begin();
  Serial.println(loxReady ? "VL53L0X ready" : "VL53L0X NOT detected");

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(300);
  }
  Serial.println("WiFi connected");

  config.database_url = DATABASE_URL;
  config.signer.tokens.legacy_token = DATABASE_SECRET;
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
}

void loop() {
  readSensors();
  updateBuzzer();

  if (millis() - lastSend >= sendInterval) {
    sendToFirebase();
    lastSend = millis();
  }
}
